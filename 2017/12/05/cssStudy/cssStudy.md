---
title: CSS学习笔记
comments: true
tags: ['CSS','学习笔记','某人口中的抄书']
---

## 《CSS权威指南》学习笔记
***学习进度 ***    	
**2017/10/23 更新 第五章进行中 **		
**2017/11/5 更新 第七章进行中 **			
**2017/11/19 更新 第10章进行中 **			
**2017/12/3 完结 **		
### 第一章 CSS和文档
想起了之前看到的一句话——**结构和表现分离的重要性。**	
>HTML弃用了之前与文档样式相关的元素，专注于文档结构。	CSS专注于文档样式。

*结构*，是由文档中的主体部分。 *表现* ,是赋予内容的一种样式，表现就是文档看起来的样子，尽可能的把结构和表现相分离。 
我们使用 HTML文档来保存内容与结构，使用CSS文档来控制整个文档的表现。这样还有一个好处就是CSS文档的可复用性，有个CSS文档可以在多个HTML文档中使用。

#### 替换元素与非替换元素  
之前自己都没有这个概念			
**替换元素:**是指用来替换元素内容的部分并非由文档内容直接表示。例如img,input标签	
**非替换元素:**大多数元素都是非替换元素，其内容由用户代理在元素本身生成的框中显示。

#### @import
@import 和 link 均是用来加载外部CSS文件的，并在表现HTML文档文档时使用。	
@import只能在CSS文件中使用，并且要放在其他CSS规则之前。

### 第二章 选择器

#### 属性选择器
1. 简单属性选择：选择具有某个属性的元素，该属性的值不做限定			
	`h1[class]{color:red;}` ——选择有class属性的h1元素，至于class的值是什么我不关心	
	还可以根据多个属性进行选择：`a[href][title]{color:red;}`——选择同时具有href和title属性的a元素

2. 根据具体属性值选择	
	`h1[class='title']{color:red;}`		
	`a[href='http://www.w3.org/'][title='W3C Home']{color:red;}`	
	当某个元素拥有两个class时，使用属性来选择，要求两个class都必须有而且是由顺序的。**实际上是一个完全串匹配**	

	在这里有提到ID选择器和指定id属性的选择器是不同的。即`h1#page-title` `h1[id='page-title']`是不同的。一开始自己只想到了最终选择的元素是一样的(然而并不一样)，并没有想出有什么不同。看了后续的内容，并明白了。这都是CSS选择器，选出特定的元素并应用我们指定的CSS样式，这两者最主要的不同就是权重不同(书中说的是特殊性)

3. 根据部分属性值选择	
	`[foo^='bar']`——foo属性值以bar开头的所有元素	
	`[foo$='bar']`——foo属性值以bar结尾的所有元素	
	`[foo*='bar']`——foo属性值中包含子串'bar'的所有元素	

4. 特定属性选择类型		
	`*[lang|='en']{color:red;}`——lang属性等于en或者以en-开头的所有元素		
	这种属性选择器最常见的用途是匹配语言值

#### CSS结合符		
1. 后代选择器		
	* 选出所有的后代元素，无论嵌套几层	
	* 以空格作为结合符
	* 这里有写到，要求**必须从右向左读选择器。**	
	HTML经过解析生成DOM Tree；在CSS解析完毕后，需要将解析的结果与DOM Tree的内容一起进行分析建立一棵Render Tree，然后渲染到浏览器上。在建立Render Tree的时候，浏览器要为每个DOM Tree中的元素根据Style Rules来确定生成怎样的render.对于每个DOM元素，必须在所有的Style Rules中找到符合的selector并将对应的规则进行合并。
	`h1 em{color:red;}` 	
	*从右向左：*首先判断是否为em元素，若不是就可以直接排除。只有在匹配了之后才会进一步判断父节点。***执行效率高	***		
	*若从左向右：*需要先找到h1元素，然后再向下找，若不匹配就必须回到上层h1。这样回溯若干次才能确定是否匹配成功。效率很低。		
2. 子元素选择器		
	* 只选择子元素而非后代元素	
	* 以 > 作为结合符	
3. 相邻兄弟元素选择器	
	* 选择紧邻在另一个元素后的元素，并且二者有相同的父元素	
	* 以 + 作为结合符		

#### 伪类伪元素		
1. 伪类		
	* 本质上还是类	
	* 链接伪类	 :link-未访问 :visited-已访问，不能把互斥的伪类结合在一起使用。
	* 动态伪类 :focus-获得焦点  :hover-鼠标悬浮  :active-激活
	* 伪类常用于超链接-a标签。			
	这里有提到伪类的顺序很重要——LoVe,HA。因为它们有相同的权重、来源和特殊性，因此与元素匹配的最后一个选择器才会胜出。
	若我们按照AHLV顺序排列链接样式，那么任何链接都不会显示:hover和:active的样式，因为:link和:visited规则后出现。所有的链接嗾使要么已访问，要么未访问，所以后面的样式会覆盖前面的样式。			
	* :first-child 用来选择元素的第一个子元素。之前的理解有误，书里也特别提到了常见的错误理解。		
		***正确的理解 ***p:first-child 选择作为某元素的第一个元素的所有P元素	
2. 伪元素	
	* 本质上还是一个元素。所有伪元素都必须出现在该伪元素的选择器的最后面。		
	* 设置首字母样式  :first-letter		
	* 设置第一行的样式	:first-line		
	* 设置之前和之后元素的样式 :before		:after	

### 第三章 结构和层叠 	
*不管怎样，无论问题看上去多抽象，多难懂，都要继续努力！你的努力不会白费。* 

#### 特殊性[权重] 	
1. ID属性值——0,1,0,0
2. CLASS属性值,属性选择或者伪类——0,0,1,0
3. TAG和伪元素——0,0,0,1
4. 结合符和通配符选择器对权重没有贡献
5. 之前自己记权重这一块的时候，都是直接按照100,10,1来记的，没有注意到前边还有一个0。这里有说明。第一个0是为内联样式样式声明保留的。				
6. !important拥有最高的权重。必须正确的放置!important,!important总是放在声明的最后		
7. 以上都是比较简单的选择器权重的基础，在实际的应用中。多是复合选择器权重的判断，只要记住基本的权重然后进行选择器的判断并进行基本权重的相加就好了。(之前这块的知识比较零散，每次看到了还要查一下)		

#### 继承	
1. 样式不仅应用到指定的元素，还会应用到它的后代元素。
2. 有些属性是不能继承的。		
3. 通配符适用于所有元素，而且有0特殊性，其指定的样式优于继承值，因为继承值根本就没有特殊性。		

#### 层叠	
1. CSS就是层叠样式表。CSS所基于的方式就是让样式层叠在一起，这是通过结合继承和特殊性做到的。	
2. 只要还是样式**顺序** 的问题。(这里的顺序指的是CSS文件引入的顺序或者样式规则在文件中的书写顺序)			
`<p class='A B'>XXX</p>` 这里的class A和B有没有优先级的问题?		
**没有没有**			[戳我戳我](http://jsbin.com/gutasetexo/3/edit?html,css,output)		
选择器的权重和类名在html中写的顺序没有半毛钱的关系。有关系的是你在CSS中写的选择器的权重以及在CSS中的顺序。	

### 第四章 值和单位		

#### 颜色
1. 表示方式	
	* 颜色名——eg:red,green,white,black	
	* RGB 
		* 函数RGB颜色——rgb(color),其中color是一个百分数或者整数三原组表示。百分数值在0%-100%，整数范围在0~255		
		eg:rgb(75%,0%,0%),rgb(255,255,255)		
    	* 十六进制RGB颜色——#RRGGGBB,将三个介于00~FF的十六进制数连接起来，就可以设置一种颜色。	
    	eg:#903bc0 ,	#FFFF(简写 #FFF)	
2. 安全颜色	
	* 所谓'Web安全'颜色是指，在256计算机系统上总能避免抖动的颜色。	
		* 0%或者0也是一个安全色。
		* 若使用RGB百分数，要让所有的三个分量都要么是0，要么是一个能被能被20整除的数。
		* 若使用0~255范围的RGB值，则个分量要么是0要么是能被51整除的数。
		* 若使用十六进制记法，使用00、33、66、99、CC和FF的三元组都被认为是安全的。	

#### 单位
1. em——定义为一种给定字体的font-size值。		
	* 一个元素的font-szie为14px，则 1em 就等于14px。	
	* 当我们在每个元素都级联em定义的字体大小时会发生什么??		[戳我戳我](https://jsbin.com/sababeh/1/edit?html,css,output)

2. rem——font-size基于根元素进行设置，在大多数情况下根元素为html元素。
3. px	
4. vh——等于viewport高度的1/100。
5. vw——等于viewport宽度的1/100。


### 第五章  字体

#### 字体系列
**划重点** -- 我们通常说的字体是一个字体系列，而不只是单个的字体。

1. font-family	
	* 应用某一通用字体系列  	
		`body {font-family:sans-serif;}`
	* 具体字体与通用字体系列的结合	
		为了保证用户电脑上没有安装这个具体字体，并且不想要是要默认字体显示。所以强烈建议在规则中提供一个通用字体系列。			
		`body {font-family:Georgia,serif;}`			
		`body{font-family: Times, TimeNR, 'New Century Schoolbook',Georgia,'New York',serif;}`--用户代理会按照列表顺序查找这些字体，若都不可用，则简单的选择一种可用的serif字体。		
		在看书的时候，看到用户代理就知识简单的直接为浏览器，其实不然。用户代理(User Agent)是用来表示浏览用户的身份，让开发者可以获得终端的信息。							
		这里还有一个，之前自己没有注意到的点，就是当字体名中出现空格或者特殊符号的时候，需要加引号。	
2. font-weight		
	自己最常用的是bold,其他的属性值用的很少。看到100-900的值是懵逼的，怎么还有这些取值				
	* 字体加粗如何起作用		
		关键字100-900，100对应最细的字体变形，900对应最粗的字体变形。一般地，400对应normal,700对应bold。每个数对应一个加粗度，它至少与前一个数制定的加粗度相同。		
		给定的字体系列中定义的具体字体少于9中的话，用户代码会自动进行填补。填补规则是根据，后一个的加粗度不会比前一个的加粗度小。	
	* bolder和lighter：它们会让文本比其父元素的字体更粗或者更细。
		基于从父元素继承到的font-family,根据元素本身的font-weight来进行加粗度的上移或上移。		
3. font-size	
	* font-size的作用是为给定字体的eme框提供一个大小，但是不能保证显示字符就是这种大小。	
	* 绝对大小:xx-small、x-small、small、medium、large、x-large和xx-large
	* 相对大小:larger和smaller。这两个关键字是元素的带下相对于其父元素的大小在绝对梯度上上移或者下移。
	* 百分比和大小
		百分比总是根据从父元素继承的大小来计算。		
		font-size是可以继承的，继承的不是百分数而是计算值。	

#### 风格和变形
1. font-style
	* normal | italic | oblique | inherit		
	* italic：斜体，一种字体风格
	* oblique：正常竖直文本的倾斜版本		
2. font-variant -- 字体变形
	* 自己平时都没有使用过，其实还是很方便的属性。这就是那种当你不知道有这个东西的时候，可能需要付出更多，知道有这么个东西的话，那真的就是很简单了。		
	* small-caps:小型大写字母。什么鬼这是!!这是我看这个属性的第一印象。即所有的字母都是大写，但是和一般的大写还有有区别的，首字母的大小要大于其他字母。		
3. font-stretch	-- 将字体水平拉伸
4. font-size-adjust --调整字体的大小
	* 当两种字体在同样的大小情况下，可能有一种字体可以辨识而另一种字体已经不能辨识了。该属性就是用来解决这用情况的。
	* 这个属性需要根据x-height 以及font-size进行计算，目前使用的概率较小。就以上的情况，我觉得大家都会选择使用font-size进行调整。		
5. font属性
	* 复合属性，自己平时使用的基本使用部分属性。		
	* [font-style][font-variant][font-weight] 这三个属性的顺序随意，若某个值为normal，就可以省略。	
	* [font-size][font-family]必须要按照这个顺序来写，而且font声明中必须要有这两个值，不能省略。	
	* 其实就是对以上的每个font样式属性，进行了整合，就是相对比较方便，不用我们每个属性都写。	

### 第六章  文本属性

#### 缩进和水平对齐
1. text-indent
	* 段落的首行缩进,应用于**块级元素**
	* 可以取负值。负值可能会超出浏览器窗口的边界，针对负缩进设置内边距或者外边距。	
	* 取值为百分比时，是相对父元素的宽度进行缩进的。	
2. text-align
	* 文本行之间的对齐方式。left | right | center | justify(两端对齐) | inherit
	* **应用于块级元素**
	* 不影响元素的对齐方式，只影响其内部内容。

#### 垂直对齐
1. line-height  [戳我戳我](http://jsbin.com/kidaborebi/edit?html,css,output)
	* 该属性是指文本行基线之间的距离、它确定了将各个元素框的告诉增加或者减少多少。	
	* line-height的值减去字体大小就是行间距。	
	* 相对于元素的字体大小
	* 取值为一个数的时候，就是缩放因子。缩放因子是继承值而不是计算值，这个数会应用到该元素及其所有子元素。	
	* 常用的就是把元素的height和line-height设置相同的值，达到垂直居中
文本行(inline box):文本行中的每个元素都会生成一个内容区，这由字体的大小确定，这个内容区就是文本行。	
引用[大神的博客](http://www.zhangxinxu.com/wordpress/2009/11/css%E8%A1%8C%E9%AB%98line-height%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/)。之前自己也一直认为是元素中的文字内容将div撑开了，但其实深究就会发现不是文字撑开了div的高度而是line-height。
2. vertical-align
	* 垂直对齐文本，**只能应用于行内元素和替换元素**
	* 该属性值不能继承
	* baseline--基线对齐,sub--下标,super--上标,bottom--底部对齐,top--顶部对齐,middle--居中对齐
	* 如果设置为一个百分数，则要根据该元素的line-height值进行计算而不是父元素的。

#### 字间隔和字母间隔
1. word-spacing
	* 接受正值或者负值，这个长度会增加到字之间的标准间隔。
	* word word 修改字间间隔
	* 该值可能受text-align属性值的影响。若text-align设置为两端对齐，字母和字之间的空间可能会调整，以实现两端对齐。
2. letter-spacing
	* 修改字母间的间隔

#### 文本转换
1. text-transform
	* uppercase | lowercase | capitalize
2. text-decoration
	* 没有继承性
	* none | underline | overline | line-through | blink(文本闪烁)
3. text-shadow
	* 为文本增加阴影
	* 三个值。前两个长度值确定了阴影与文本的偏移距离，第三个长度值可选，定义阴影的'模糊半径'
4. white-space
	* 影响浏览器处理字之间和文本行之间的空白符的方式。
	* normal：默认值。所有的空白符都合并为一个空格
	* pre:空白符不会被忽略
	* nowrap:不允许自动换行，空白符会进行合并
	* pre-line:空白符合并，换行符保留
	* pre-wrap：空白符和换行符都会保留。

### 第七章  基本视觉格式化
#### 基本框(盒模型)		

content,padding,border,margin   
IE盒模型:margin+width(content+padding+border)   
W3C盒模型:margin+border+padding+contnet         
CSS3 **box-sizing**: content-box(在元素指定的宽度和高度之外增加padding，border)|border-box(在元素指定的宽度和高度之内增加padding，border)|inherit;

#### 块级元素
块级元素在正常的文本流中，会在其之前和之后生成‘换行’。所以说块级元素会独占一行，正常流中的块级元素会垂直摆放。通过display：block;可以让元素生成块级框。

margin可以为负值，但是padding不可以。垂直方向上的外边距会出现高度塌陷的现象，合并之后的外边距不取两者之和，而是去两者之中较大的值。

#### 行内元素
在元素的前后不会生成‘行分隔符’，通过display:inline，可以让元素生成一个行内框就是变成一个行内元素喽。		
行内元素在正常文本流中是一个挨着一个一行一行的堆放的。

#### display属性
display改变的只是元素的显示角色，而不是其本质。     
* inline-block 行内块级元素，可以设置width,height属性                          
* run-in 元素会根据上下文作为块级元素或者内联元素显示       
	若设置display：run-in元素的后面是紧跟的是一个块级元素则该元素会作为块级元素的一个行内元素；     
	display:run-in元素后面没有跟一个块级元素，则该元素就会成为一个会计元素。        

### 第八章 内边距、边框和外边距			
#### 宽度和高度			
不能应用到行内非替换元素。		

#### 外边距 margin   		
* margin的默认值是0，但是浏览器对许多元素已经提供了预定的样式。这也就是我们写css的时候会出现一些公用的初始化样式的原因。		
* margin:上 右 下 左(4个值)		
* margin:上下 左右(2个值)	值复制	
* margin设置百分数是相对于父元素的width计算的。这会得到‘流式’页面，即元素的外边距会扩大或者缩小以适应父元素的实际大小。		

#### 边框 border
border:1px solid red;每个边框都有3个方面，宽度、样式和颜色。

#### border-style 边框样式
* none | dotted | dashed |　solid | inset | outset | double
* double定义两条线的宽度再加上这两条线之间的空间等于border-width
* border-style:top right bottom left;设置多种样式，或者进行单边设置 border-style-top

#### border-width 边框宽度
* thin |　medium | thick | length
* 根本没有边框：border-style:none

#### border-color 边框颜色
* 默认颜色是元素的前景色
* 也可以进行单边设置
* 透明边框 border-color:transparent;

以上关于border的三个方面，可以使用简写属性 border来完成，而且三者的顺序并不重要。如果少一个值，就会自动填入默认值。当然，无论为行内元素的帮狂制定怎样的宽度，行内元素的行高还是不会改变的。		

#### 内边距 padding
* 默认情况下元素是没有padding的，元素的背景会延伸到其内边距但是不会延伸到外边距。
* 设置内边距为百分数，则也是相对于它父元素的width进行计算的。上下内边距会相对其父元素的宽度进行计算而不是高度。
* 也可以设置单边内边距 padding-top	

### 第九章  颜色和背景
#### 颜色
1. 前景色 
    * 设置元素的前景色，使用colro属性。	 
    * color值会影响元素周围的边框，要覆盖这种默认颜色，可以使用border-color	
    * color属性可以继承
2. 背景
    * background-color 设置背景色，默认值是transparent,背景颜色不能继承。
    * background-image 设置背景图片，不能继承。在使用背景图片的时候最好再制定一个背景颜色。	
    * background-repeat 背景图片的重复 repeat | repeat-x| repeat-y |no-repeat
    * background-position 背景定位      
	关键字:top bottom left right,不能超过两个关键字，一个对应水平方向，一个对应垂直方向。       
	百分数值,同时应用于元素和原图像，使用百分数值时，总是水平值先出现的。       
	background-position的默认值0% 0%，相当于background-position:top left;       
    * background-attachment scroll |　fixed | inherit           
	如果一个文档超级长，我们将背景图片放在body元素的中心，那么这个背景图片开始是对用户不可见的，必须要向下滚动滚动条才能看到背景图片。      
	background-attachment:fixed; 背景图片不会随着文档滚动，背景图片的位置由可视区的大小确定而不是包含该元素的大小。	
	background-attachment:scroll;会导致背景随其文档滚动。

以上的以上，都可以使用一个简写属性,也是使用最多的. background，以上各个属性不限定顺序，若有没设置的，则使用默认值。

### 第十章 浮动和定位		
#### 浮动		
* float:left| right| none| inhert
* 该属性可以应用于所有元素	

1. 浮动元素
	* 浮动元素会脱离正常文档流，但是还是会影响布局。我们会当一个元素浮动时，其他内容会‘环绕该元素’。
	* 浮动元素周围的外边距是不会合并的。
	* 如果浮动元素为非替换元素，则必须为这个元素声明一个width。
2. 深入浮动
	* 包含块：距离浮动元素最近的块级祖先元素
	* 无论元素本身是块级元素还是内联元素，设置浮动属性后该元素就会生成一个块级框。
	* 浮动规则：
		*	浮动元素的左右外边界不能超出其包含块的左右内边界
		*	浮动元素的左右外边界必须是源文档中之前出现的左浮动或者右浮动元素的左右边界，除非后出现的浮动元素的顶端在先浮动元素的底端下面。这个话呢，要读上两遍才能明白说的什么意思，简而言之说的就是浮动元素的先来后到，以及浮动元素之间是不会发生重叠的。
		*	一个浮动元素的顶端不能比其父元素的内顶端更高。
		*	浮动元素的顶端不能比之前所有浮动元素或块级元素的顶端更高。
		*	浮动元素不能超出其包含块的边界，当浮动元素的包含块空间不足时，浮动元素会被挤到下一行。
		* 	书上写的浮动规则比较多，我这里只列举了几项。这里说的多是浮动元素之前以及于东元素与父元素的规则，但是在实际的开发中我们碰到比较多的还是浮动元素与正常文档流中元素的布局情况。这里是让我们对于浮动的基础规则有个比较清晰的认识。	
3. 实用行为		
	* 当浮动元素比父元素高时，在上述的规则中我们有提到浮动元素的顶端不能超过之前的浮动元素的底端或者包含块的顶端。这种情况下，我们可以将父元素置为浮动元素，这样就可以把浮动元素包含在父元素内。		
	* 浮动元素超出父元素的所有边界：1.负外边距2.浮动元素比父元素更宽。
	* 浮动元素、内容和重叠。内联元素完全覆盖浮动元素，该块级元素其内容显示在浮动元素之上，其余部分(background,border等)显示在浮动元素之下。
	* 清除浮动 clear.恩，之前感觉自己都是稀里糊涂的在用，现在可算是搞明白了。clear属性应用于块级元素，both确保该元素不会与如何浮动元素在同一行上，即左右浮动都清除。clear:left|right同理，即该元素的左边或者右边没有浮动元素。	

#### 定位	

* 利用定位可以准确地定义元素狂相对于其正常位置应该出现在哪里或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。	
* position:static| relative| absolute| fixed| inherit
1. 定位类型
	* static(默认值) 元素在正常文档流中的位置
	* relative 相对定位，相对于该元素在正常文档流中为位置进行定位，该定位元素原本的位置仍然保留。	
	* absolute 绝对定位，相对于最近的position取值不是static的祖先元素进行定位，该元素从文档流完全删除，在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。如果所有的祖先元素都没有position取值不为static的，则该元素相对于根元素进行定位。
	* 在这里，书上说的是包含块，即上面介绍的相对的那个元素。还要一点，元素可以定位到包含块的外面。
2. 偏移属性
	* 以上的介绍的定位，知识该元素进行定位了，但实际上并没有进行偏移。定位的目的就是要改变元素的位置，要是元素到达你想让他去的地方的话，需要使用偏移属性实现。
	* top、left、bottom、right,设置position且取值不为static的元素，才能使用偏移属性进行定位。
	* top 、bottom是相对于包含块的高度，left和right是相对于包含块的宽度。偏移属性取值为正值会导致向内偏移，即边界朝着包含块的中心移动，负值会导致向外偏移。
	* 通过使用负值可以将一个元素定位到包含块之外。
3. 宽度和高度
	* 定位元素的宽度和高度可以有偏移属性取值隐含确定。
	* 限制宽度和高度 min-width,min-height,max-width,max-height.这些属性的取值不能为负。
	* 限制宽度和高度的正确使用方法，配合百分比大小的同时，设置基于长度的限制。可以相对安全的混用不同的单位。
4. 内容溢出和剪裁
	* 溢出
		* 一个元素的内容对于元素大小来说太大了，就可能溢出元素本身。
		* overflow:visible(默认值)| hidden| scroll| auto| inhert
		* visible，元素的内容在元素框外边不可见。scroll,生成滚动条。hidden会在元素框的边界处剪裁。
	* 剪裁
		* 绝对定位的元素内容溢出其内容框，并且overflow属性要求剪裁其内容，则可以使用clip属性剪裁区域的形状。
		* rect(top,right,bottom,left)制定剪裁形状为矩形以及4个边的长度，可以设置负值
5. 元素可见性
	* visibility:visbile| hidden| collapse| inherit
	* visible,元素不可见，元素还是会影响文档的布局，位置还在，就好像它还可见一样。display:none;不可见，不影响布局，该元素在文档中的位置不存在。display:none在生成渲染树的时候，不会存在。
6. 绝对定位
	* Z-index应用于定位元素，可以改变元素相互覆盖的顺序。z-index可以取值为负值
7. 固定定位
	* 固定定位元素的包含块是视窗。元素会完全从文档流中去除，不会有相对于文档中任何部分的位置。
	* 固定定位的另一个用途是在屏幕上放置一个‘永久性’元素，不随文档滚动而滚动。
8. 相对定位
	如果遇到过度受限的相对定位，一个值会被重置为另一个值的相反数。即bottom总是等于-top.

### 第十一章 表布局	

#### 表显示值
* table,生成块级表
* inline-table,生成行内级表
* table-row,指定一个元素为一个单元格的行，相应的HTML元素为tr元素
* table-row-group,指定一个元素是一个或多个行的组，对应的HTML元素是tbody元素
* table-header-group,指定一个元素为标题组包含多个行，相应的HTML元素是thead元素
* table-footer-group,类似于table-row-group,table-header-group,指定一个元素为脚注行组，相应的HTML元素是tfoot
* table-column,指定一个元素是一个单元格的列，相应的HTML元素是col元素
* table-column-group,指定一个元素是一个或多个列的组，相应的HTML元素是colgroup元素
* table-cell,指定一个元素表示表中的单个单元格，HTML元素th和td都属于table-cell元素
* table-caption,之低昂一个元素为一个表的总标题

#### 以行为主
* css将表模型定义为‘以行为主’，而列是从行单元格行的布局中推导出来的
* 在css中，列和列组只能接受4种样式：border,background,width和visibility,这4个属性有一些只能应用于列上下文的特殊规则
* border
	* 只有当border-collapse:collapse;时才能为列或者列组设置边框
	* background,只有当单元格及其行的背景为透明时，列或列组的背景才可见，
	* width,定义列或列组的最小宽度
	* visibility,如果一个列或列组的visibility:collapse;则该列组中所有单元格斗不显示。

#### 匿名表对象
* CSS定义了一种机制，可以将'遗漏的'组件作为匿名对象插入。其实可以简单的理解为，css要求表结构必须完整，为了方便使用表结构，当代码省略了某些结构的时候，将自动进行插入相应的元素以保证表结构的完整。
* 对象插入规则
	* table-cell的父元素不是table-row，则会插入table-row作为table-cell的父元素。
	* table-row的父元素不是table,inline-table,table-row-group，则会插入table元素，并且新插入的元素将包含该table-row元素的多有连续兄弟元素。
	* table-column的父元素不是table,inline-table或者table-column-group,则插入匿名的table元素作为table-column的父元素。
	* 如果table-row-group,table-header-group,table-footer-group,table-column-group或table-caption的父元素不是table元素，则插入一个匿名的table元素作为父元素。
	* ......
	* 插入规则还有一些，我就不一一罗列了，都是相对简单的插入规则。

#### 表层
前面有介绍background属性应用于列，只能是行或者行组的背景为透明时，但是这个为什么呢??  答案就在这里，[层级关系](http://ozq46i4wc.bkt.clouddn.com/%E8%A1%A8%E5%B1%82.jpg)
* 开心，终于把七牛云搞定了。之前一直说是要加图片但是七牛云不会用，其实真的是so easy!妈妈再也不用担心为的学习了
* 从上面的这张图中我们很清楚的看到table的层级关系，表各个方面的样式都在其各自的层上进行绘制。从图中我们看到顶层是表单元格，将在最后进行绘制。
* 有一点需要提箱一下，默认的情况下，所有元素的背景都是透明的。所以呢，也就说，如果单元格，行，列都没有自己的背景则table元素的背景将显示出来。

#### 表标题
* 设置display:table-caption;的元素
* 表标题可以位于table之上或者table之下，使用caption-side属性就可以进行设置。注意这个属性只能应用于display:table-caption的元素
* 对之前介绍过的run-in还有影响吗?我造，是dispaly属性的一个取值，会根据情况不同来表现为款及元素或内联元素。在这里有一点需要进行说明，如果一个run-in元素位于table之前，它不会进入表的上标题，也不会进入表中，而是处理为display:block

#### 表单元格边框
* border-collapse:collapse(合并边框模型)| separate(分隔边框模型)| inherit
* separate(分隔边框模型)
	* 表中的每个单元格斗鱼其他单元格分开一定距离，而且单元格的边框彼此不会合并。
	* 边框间隔 border-spacing,该属性用来定义table的边框间隔，只能应用于dispaly:table/inline-table的元素
	* border-spacing提供两个长度，要求第一个值始终是水平间隔，第二个值始终是垂直间隔
	* 空单元格 empty-cells:show;会画出空单元格的边框和北京，就好像这些表单元格有内容一样。empty-cells:hide;不会画出该单元格的任何部分，就好像这个单元格设置visibility:hidden
* collapse(合并边框模型)
	* diaplay:table/inline-table;的元素不能有任何的内边距，但是可以有外边距。也就说表的边框和最外边的表单元格之间没有任何间隙
	* 边框可以应用到单元格、行、行组、列和列组，当然表元素本身也是有一个边框的
	* 边框合并
		* 如果两个或多个边框相邻，他们会互相合并。
		* 合并规则又来了，好吧，我尽量不抄书，写的简单易懂一点
			* border-style:hidden的优先级最高，这个位置上的所有边框将都会隐藏
			* border-style:none的优先级最低，border-style的默认值就是none
			* 如果border-style不全是none，那么就是这样的，比较boreder-width，窄边不敌宽边
			* 最后的最后，如果还是不知道决断不出来那要怎么办呢？？比较颜色吧，border也就只剩个border-style，哈哈哈哈


#### 表大小
* 表宽度的确定有两种方法：固定宽度布局和自动宽度布局 table-layout,这两种布局有一个很明显的差异那就是速度
* 不论使用哪种宽度布局，表高度都是自动计算的
* 固定布局 table-layout:fixed
	* 固定布局相对自动宽度布局更快，那这是为什么呢?脑子笨就要多思考，因为是固定的呀，布局不需要依赖于表单元格的内容，布局是根据表中的列和单元格的width值决定的。
	* 表的宽度设置为表的width值或列宽度之和(取这两个钟较大者)，表的宽度在表的第一行渲染出来的时候已经定了，后面不需要再改变表的宽度了。
* 自动布局
	* 当表的width为auto的时候就会触发自动布局
	* 表布局完全取决于表内容，在生成全部表内容之前无法确定表的布局

### 第十二章 列表与生成内容	

#### 列表
* display:list-item的元素
* 列表类型 list-style-type,只能应用于display：list-item的元素，改变列表元素前面的小样式(其实人家是叫做显示标志)
* CSS无法区分有序列表和无序列表
* 列表项图像 list-style-image：url();这里提醒一下，为了防止图像未加载，被破坏等无法显示的情况，我们需要在list-style-image之后设置一个备用的list-style,这样做是最安全的
* 列表标志位置 list-style-position:inside| outside| inherit
* 简写形式就是list-style，这个之间介绍的好多属性都是一样的，我相信你懂得。可以按照任何顺序出现，并且这些值都是可以忽略的
* 列表布局
	* 如果列表显示标志是在列表项内容的外面，则不会影响列表的布局，也不会影响列表项本身的布局
	* 如果列表显示标志是在列表项的内部的话，就相当于在列表内容开始出防止了一个行内元素


#### 生成内容
* 还没看内容的时候我就在想，生成内容到底是个什么鬼，讲什么呀。看了内容有种，哦，原来这就是生成内容呀。就是感觉自己之前知道知识点，但是并没有这么专业的知道学术上叫啥。好吧，作为专业的前端工程师，还是要知道的
* 生成内容是指由浏览器生成的而不是有标志或者内容来表示。上面介绍的列表标志就是生成内容，在代码中并没有任何代码直接表示这些标志
* 插入生成内容
	* 伪元素 :before 和 :after(对，没错就是他俩)
	* :before/:after{content:''} content中的内容就是插入的生成内容，注意了生成内容和元素内容之间是没有空格的。除非你在content中包含空格
	* 我写了上边我自己的描述，发现content叫指定内容，哈哈哈哈，没有关系了就是一个意思
	* 插入属性值:取一个元素的属性值，使之作为文档显示的一部分。如果一个属性不存在，会在相应位置插入一个空串
	* 生成引号 quotes，传两个串，前一个串定义开始引号，第二个串定义结束引号


#### 计数器
* 有序列表中的列表标志就是计数器
* 重置和递增
	* 设置计数器的起点 counter-reset。计数器默认值是0
	* 设置计数器递增 counter-increment
* 实际上，任何元素都可以利用计数器

### 第十三章 用户界面样式	

#### 系统字体和颜色
为了尽可能的模仿用户环境的计算机环境，我们可以使用系统字体和颜色，来让web组件看上去是用户操作系统的一部分。
1. 系统字体
* 提供了6种系统字体关键字
* caption,icon,menu,message-box,small-caption,status-bar
* 这些值，只能用于font属性，以上的这些值，他们本身就是简写属性

2. 光标
* 利用cursor,可以将任何元素定义为像链接一样改变光标图标
* cursor:pointer 将光标改变为手型
* cursor:move 一颗改变光标为一个加粗的十字架，线的两端有箭头。也可以是一个‘拳头’
* cursor:wait/progress 都只是程序正在忙，wait表示需要一直等待，直到程序不忙的时候，而progress表示用户完全还可以继续和程序进行交互，虽然程序现在很忙
* cursor:help 可以一个问号，也可以是一个箭头旁边有一个小问号
* cursor:url('XXX') pointer; 图形光标，无论使用什么图形光标，要求再设置一个光标属相值作为备选

3. 轮廓
* 轮廓有点类似于边框，但是二者之间有很大的区别
* 轮廓是不会像边框那样参与到文档流中，因此轮廓出现或者消失是不是影响文档流，既不会导致文档的重新显示
* 轮廓和边框不是同一个东西，但是他们可以作用在同一个元素上
* 轮廓一般用于指示当前焦点
* 设置轮廓样式 outline_style,与边框的关键字基本一样。这里有一点不一样是 只能为outline-style之低昂一个关键字，而不能像边框那样，指定4个不同的值
* 一个元素周围必然有相同的轮廓样式，而不论轮廓是否是矩形
* 轮廓宽度 outline-width
* 轮廓颜色 outline-color
* outline 简写属性

### 第十四章 非屏幕媒体		
* 主要针对视觉障碍者，进行一些设计
* 主要内容包括
	* 设计特定于媒体的样式表
	* 分页媒体
	* 声音样式